import { Telegraf, Markup, Context } from "telegraf";
import { config } from "dotenv";
import fs from "fs";
import path from "path";
import { createHash } from "crypto";

config();

interface UserState {
  diagnosis?: string;
  sections?: string[];
  messageIds?: number[];
  // –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –º–∞–ø–ø–∏–Ω–≥–∞ —Ö—ç—à–µ–π –∫ —Ä–µ–∞–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
  callbackMap?: {
    [key: string]: string;
  };
}

interface BotContext extends Context {
  userState?: UserState;
}

interface SessionData {
  [userId: number]: UserState;
}

class SessionManager {
  private sessionFile: string;
  private sessionData: SessionData = {};

  constructor(sessionFileName: string = "session.json") {
    this.sessionFile = path.join(__dirname, sessionFileName);
    this.loadSessions();
  }

  private loadSessions(): void {
    try {
      if (fs.existsSync(this.sessionFile)) {
        const data = fs.readFileSync(this.sessionFile, "utf8");
        const parsedData = JSON.parse(data);

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Map –∏–∑ —Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
        this.sessionData = Object.fromEntries(
          Object.entries(parsedData).map(([userId, state]: [string, any]) => {
            if (state.callbackMap && Array.isArray(state.callbackMap)) {
              state.callbackMap = new Map(state.callbackMap);
            }
            return [userId, state];
          })
        );
        console.log(`–°–µ—Å—Å–∏–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ ${this.sessionFile}`);
      }
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–µ—Å—Å–∏–π:", error);
      this.sessionData = {};
    }
  }

  private saveSessions(): void {
    try {
      // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Map –≤ –º–∞—Å—Å–∏–≤ –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
      const serializableData = Object.fromEntries(
        Object.entries(this.sessionData).map(([userId, state]) => {
          const serializableState = { ...state };
          if (state.callbackMap instanceof Map) {
            serializableState.callbackMap = Array.from(state.callbackMap.entries());
          }
          return [userId, serializableState];
        })
      );

      fs.writeFileSync(this.sessionFile, JSON.stringify(serializableData, null, 2));
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–µ—Å—Å–∏–π:", error);
    }
  }

  getUserState(userId: number): UserState | undefined {
    return this.sessionData[userId];
  }

  setUserState(userId: number, state: UserState): void {
    this.sessionData[userId] = state;
    this.saveSessions();
  }

  updateUserState(userId: number, update: Partial<UserState>): void {
    if (!this.sessionData[userId]) {
      this.sessionData[userId] = {};
    }

    this.sessionData[userId] = { ...this.sessionData[userId], ...update };
    this.saveSessions();
  }

  deleteUserState(userId: number): void {
    if (this.sessionData[userId]) {
      delete this.sessionData[userId];
      this.saveSessions();
    }
  }

  clearAllSessions(): void {
    this.sessionData = {};
    this.saveSessions();
  }
}

class HttpClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  async get<T>(endpoint: string, params?: Record<string, string>): Promise<T> {
    const url = new URL(endpoint, this.baseURL);

    if (params) {
      Object.keys(params).forEach((key) => {
        url.searchParams.append(key, params[key]);
      });
    }

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return response.json();
  }
}

class MedicalBot {
  private bot: Telegraf<BotContext>;
  private sessionManager: SessionManager;
  private httpClient: HttpClient;

  constructor(token: string, apiBaseURL: string) {
    this.bot = new Telegraf<BotContext>(token);
    this.sessionManager = new SessionManager();
    this.httpClient = new HttpClient(apiBaseURL);

    this.setupMiddlewares();
    this.setupHandlers();
  }

  private setupMiddlewares() {
    this.bot.use((ctx, next) => {
      const userId = ctx.from?.id ?? 0;

      if (userId) {
        const userState = this.sessionManager.getUserState(userId) || {
          messageIds: [],
          callbackMap: {},
        };
        ctx.userState = userState;
      }

      return next();
    });
  }

  private setupHandlers() {
    this.bot.start(async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await this.sendWelcomeMessage(ctx);
    });

    this.bot.command("new_diagnosis", async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await this.askForNewDiagnosis(ctx);
    });

    this.bot.on("text", async (ctx) => {
      const userInput = ctx.message.text.trim();
      const userId = ctx.from?.id;

      if (userInput.startsWith("/")) {
        return;
      }

      if (!userId) return;

      await this.clearPreviousMessages(ctx);
      await this.handleDiagnosisInput(ctx, userInput);
    });

    this.bot.action(/select_diagnosis:(.+)/, async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await this.handleDiagnosisSelection(ctx);
    });

    this.bot.action(/select_section:(.+)/, async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await this.handleSectionSelection(ctx);
    });

    this.bot.action("new_diagnosis", async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await this.askForNewDiagnosis(ctx);
    });

    this.bot.on("message", async (ctx) => {
      await this.clearPreviousMessages(ctx);
      await ctx.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –≤–≤–æ–¥–∞ –¥–∏–∞–≥–Ω–æ–∑–∞ –∏–ª–∏ –∫–æ–º–∞–Ω–¥—ã –º–µ–Ω—é.");
    });
  }

  private generateHash(text: string): string {
    return createHash("sha256").update(text).digest("hex").substring(0, 32);
  }

  private async storeCallbackMapping(
    ctx: BotContext,
    originalValue: string,
    type: "diagnosis" | "section"
  ): Promise<string> {
    const userId = ctx.from?.id;
    if (!userId || !ctx.userState) return "";

    const hash = this.generateHash(originalValue);
    const key = `${type}:${hash}`;

    if (!ctx.userState.callbackMap) {
      ctx.userState.callbackMap = {};
    }

    ctx.userState.callbackMap[key] = originalValue;

    this.sessionManager.updateUserState(userId, { callbackMap: ctx.userState.callbackMap });

    return hash;
  }

  private async resolveCallbackMapping(ctx: BotContext, callbackData: string): Promise<string | null> {
    const userId = ctx.from?.id;

    if (!userId || !ctx.userState || !ctx.userState.callbackMap) return null;

    return ctx.userState.callbackMap[callbackData] || null;
  }

  private async clearPreviousMessages(ctx: BotContext) {
    const userId = ctx.from?.id;
    if (!userId || !ctx.userState || !ctx.userState.messageIds || ctx.userState.messageIds.length === 0) {
      return;
    }

    try {
      for (const messageId of ctx.userState.messageIds) {
        try {
          await ctx.deleteMessage(messageId);
        } catch (error) {
          console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ ${messageId}:`, error);
        }
      }

      // –û—á–∏—â–∞–µ–º callback mapping –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏–π
      this.sessionManager.updateUserState(userId, {
        messageIds: [],
        callbackMap: {},
      });
      if (ctx.userState) {
        ctx.userState.messageIds = [];
        // ctx.userState.callbackMap = {};
      }
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:", error);
    }
  }

  private saveMessageId(ctx: BotContext, messageId: number) {
    const userId = ctx.from?.id;
    if (!userId || !ctx.userState) return;

    const messageIds = ctx.userState.messageIds || [];
    messageIds.push(messageId);

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ —Ñ–∞–π–ª–µ
    this.sessionManager.updateUserState(userId, { messageIds });
    ctx.userState.messageIds = messageIds;
  }

  private async sendWelcomeMessage(ctx: BotContext) {
    const userId = ctx.from?.id;
    if (!userId) return;

    const welcomeText = `üëã –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, –¥–æ–∫—Ç–æ—Ä!
–Ø ‚Äî DocTime.MedX, –≤–∞—à–∞ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∞—è –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π.
–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å ‚Äî –∏ —è –ø–æ–º–æ–≥—É –Ω–∞–π—Ç–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∫–ª–∏–Ω–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏, –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–ª–∏ –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –ø–æ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–µ –∏ –ª–µ—á–µ–Ω–∏—é.

ü©∫ –î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω—ë–º: –∫–∞–∫–æ–π –∑–∞–ø—Ä–æ—Å —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ–±—Ä–∞—Ç—å?`;

    const message = await ctx.reply(
      welcomeText,
      Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
    );

    this.saveMessageId(ctx, message.message_id);
  }

  private async askForNewDiagnosis(ctx: BotContext) {
    const userId = ctx.from?.id;
    if (!userId) return;

    const message = await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–∏–∞–≥–Ω–æ–∑–∞, –∫–æ—Ç–æ—Ä—ã–π –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç:");
    this.saveMessageId(ctx, message.message_id);
  }

  private async handleDiagnosisInput(ctx: BotContext, userInput: string) {
    const userId = ctx.from?.id;
    if (!userId) return;

    try {
      const searchingMessage = await ctx.reply("–ò—â—É –ø–æ—Ö–æ–∂–∏–µ –¥–∏–∞–≥–Ω–æ–∑—ã...");
      this.saveMessageId(ctx, searchingMessage.message_id);

      const similarDiagnoses = await this.getSimilarDiagnoses(userInput);

      if (similarDiagnoses.length === 0) {
        const notFoundMessage = await ctx.reply(
          "–ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–π –¥–∏–∞–≥–Ω–æ–∑ –∏–ª–∏ —É—Ç–æ—á–Ω–∏—Ç—å —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫—É.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, notFoundMessage.message_id);
        return;
      }

      // –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ —Å —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ callback_data
      const buttons = await Promise.all(
        similarDiagnoses.map(async (diagnosis) => {
          const hash = await this.storeCallbackMapping(ctx, diagnosis, "diagnosis");
          return [Markup.button.callback(diagnosis, `select_diagnosis:${hash}`)];
        })
      );

      buttons.push([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")]);

      const diagnosisMessage = await ctx.reply(
        "–ù–∞–π–¥–µ–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –¥–∏–∞–≥–Ω–æ–∑—ã. –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π:",
        Markup.inlineKeyboard(buttons)
      );
      this.saveMessageId(ctx, diagnosisMessage.message_id);
    } catch (error) {
      console.error("Error getting similar diagnoses:", error);
      const errorMessage = await ctx.reply(
        "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –¥–∏–∞–≥–Ω–æ–∑–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
      );
      this.saveMessageId(ctx, errorMessage.message_id);
    }
  }

  private async handleDiagnosisSelection(ctx: BotContext) {
    const userId = ctx.from?.id;
    if (!userId) return;

    try {
      await ctx.answerCbQuery();

      const hash = ((ctx as any).match as RegExpMatchArray)[1];

      const diagnosis = await this.resolveCallbackMapping(ctx, `diagnosis:${hash}`);

      if (!diagnosis) {
        const errorMessage = await ctx.reply(
          "–û—à–∏–±–∫–∞: –¥–∏–∞–≥–Ω–æ–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, errorMessage.message_id);
        return;
      }

      this.sessionManager.updateUserState(userId, { diagnosis });
      if (ctx.userState) {
        ctx.userState.diagnosis = diagnosis;
      }

      const loadingMessage = await ctx.reply(`–í—ã–±—Ä–∞–Ω –¥–∏–∞–≥–Ω–æ–∑: ${diagnosis}\n\n–ó–∞–≥—Ä—É–∂–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é...`);
      this.saveMessageId(ctx, loadingMessage.message_id);

      const sections = await this.getSections(diagnosis);

      if (sections.length === 0) {
        const noInfoMessage = await ctx.reply(
          "–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–≥–Ω–æ–∑–∞ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, noInfoMessage.message_id);
        return;
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ–∫—Ü–∏–∏ –≤ —Å–µ—Å—Å–∏–∏
      this.sessionManager.updateUserState(userId, { sections });
      if (ctx.userState) {
        ctx.userState.sections = sections;
        ctx.userState.diagnosis = diagnosis;
      }

      // –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ —Å —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ callback_data –¥–ª—è —Å–µ–∫—Ü–∏–π
      const buttons = await Promise.all(
        sections.map(async (section) => {
          const hash = await this.storeCallbackMapping(ctx, section, "section");
          return [Markup.button.callback(section, `select_section:${hash}`)];
        })
      );

      buttons.push([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")]);

      const sectionsMessage = await ctx.reply("–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–∞–∑–¥–µ–ª—ã:", Markup.inlineKeyboard(buttons));
      this.saveMessageId(ctx, sectionsMessage.message_id);
    } catch (error) {
      console.error("Error getting diagnosis sections:", error);

      const errorMessage = await ctx.reply(
        "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
      );

      this.saveMessageId(ctx, errorMessage.message_id);
    }
  }

  private async handleSectionSelection(ctx: BotContext) {
    const userId = ctx.from?.id;
    if (!userId) return;

    try {
      await ctx.answerCbQuery();

      const hash = ((ctx as any).match as RegExpMatchArray)[1];
      const sectionTitle = await this.resolveCallbackMapping(ctx, `section:${hash}`);

      if (!sectionTitle) {
        const errorMessage = await ctx.reply(
          "–û—à–∏–±–∫–∞: —Ä–∞–∑–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, errorMessage.message_id);
        return;
      }

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞
      const userState = this.sessionManager.getUserState(userId);
      if (!userState || !userState.sections) {
        const errorMessage = await ctx.reply(
          "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, errorMessage.message_id);
        return;
      }

      const diagnosis = userState.diagnosis;
      if (!diagnosis) {
        const errorMessage = await ctx.reply(
          "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, errorMessage.message_id);
        return;
      }

      const section = userState.sections.find((s) => s === sectionTitle);

      if (!section) {
        const notFoundMessage = await ctx.reply(
          "–†–∞–∑–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.",
          Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
        );
        this.saveMessageId(ctx, notFoundMessage.message_id);
        return;
      }

      const content = await this.getSection(diagnosis, section);

      const sectionMessage = await ctx.reply(
        `${section}\n\n${content}`,
        Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
      );

      this.saveMessageId(ctx, sectionMessage.message_id);
    } catch (error) {
      console.error("Error handling section selection:", error);

      const errorMessage = await ctx.reply(
        "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞–∑–¥–µ–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        Markup.inlineKeyboard([Markup.button.callback("–í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –¥–∏–∞–≥–Ω–æ–∑", "new_diagnosis")])
      );

      this.saveMessageId(ctx, errorMessage.message_id);
    }
  }

  private async getSimilarDiagnoses(diagnosis: string): Promise<string[]> {
    try {
      const response = await this.httpClient.get<any>("/diagnoses/similar", { diagnosis });

      return response.diagnoses;
    } catch (error) {
      console.error("API Error - getSimilarDiagnoses:", error);
      throw new Error("Failed to get similar diagnoses");
    }
  }

  private async getSections(diagnosis: string): Promise<string[]> {
    try {
      const response = await this.httpClient.get<any>(`/diagnoses/${diagnosis}/sections`, {});

      return response.sections;
    } catch (error) {
      console.error("API Error - getDiagnosisSections:", error);
      throw new Error("Failed to get diagnosis sections");
    }
  }

  private async getSection(diagnosis: string, section: string) {
    try {
      const response = await this.httpClient.get<any>(`/diagnoses/${diagnosis}/sections/${section}`, {});

      return response.content;
    } catch (error) {
      console.error("API Error - getDiagnosisSections:", error);
      throw new Error("Failed to get diagnosis sections");
    }
  }

  public launch() {
    this.bot.launch(() => {
      console.log("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω");
    });

    // Graceful shutdown
    process.once("SIGINT", () => {
      console.log("–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π –ø–µ—Ä–µ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ–º...");
      this.bot.stop("SIGINT");
    });
    process.once("SIGTERM", () => {
      console.log("–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π –ø–µ—Ä–µ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ–º...");
      this.bot.stop("SIGTERM");
    });
  }
}

const BOT_TOKEN = process.env.BOT_TOKEN || "";
const API_BASE_URL = process.env.API_BASE_URL || "http://localhost";

if (!BOT_TOKEN) {
  console.error("Please set BOT_TOKEN environment variable");
  process.exit(1);
}

if (!API_BASE_URL) {
  console.error("Please set API_BASE_URL environment variable");
  process.exit(1);
}

const medicalBot = new MedicalBot(BOT_TOKEN, API_BASE_URL);
medicalBot.launch();
